////////////////////////////////////////////////////////////////////////
// Class:       CoherentPionReco
// Module Type: analyzer
// File:        CoherentPionReco_module.cc
//
// Generated at Tue Mar 27 12:29:30 2018 by Jonathan Asaadi using artmod
// from cetpkgsupport v1_13_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "canvas/Persistency/Common/Ptr.h"
#include "canvas/Persistency/Common/PtrVector.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "canvas/Persistency/Common/FindMany.h"
#include "canvas/Persistency/Common/FindOneP.h" 
#include "canvas/Persistency/Common/FindManyP.h"



// ########################
// ### LArSoft INcludes ###
// ########################
#include "nusimdata/SimulationBase/MCTruth.h"
#include "larsim/MCCheater/BackTracker.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/TrackHitMeta.h"
#include "lardataobj/RecoBase/SpacePoint.h"
#include "lardata/ArtDataHelper/TrackUtils.h" // lar::util::TrackPitchInView()
#include "lardataobj/RecoBase/Vertex.h"



// #####################	
// ### ROOT includes ###
// #####################
#include "TComplex.h"
#include "TFile.h"
#include "TH2D.h"
#include "TF1.h"
#include "TTree.h"


class CoherentPionReco;

class CoherentPionReco : public art::EDAnalyzer {
public:
  explicit CoherentPionReco(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  CoherentPionReco(CoherentPionReco const &) = delete;
  CoherentPionReco(CoherentPionReco &&) = delete;
  CoherentPionReco & operator = (CoherentPionReco const &) = delete;
  CoherentPionReco & operator = (CoherentPionReco &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;
  void endJob() override;
  void reconfigure(fhicl::ParameterSet const & p) override;


private:

   std::string fGenieGenModuleLabel;
   std::string fTrackModuleLabel;
   std::string fVertexModuleLabel;

  // Declare member data here.

};

// #############################################################
// ####                  FHICL Parameter Set                 ###
// #############################################################
CoherentPionReco::CoherentPionReco(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{this->reconfigure(p);}

// #############################################################
// ###                        Reconfigure                    ###
// #############################################################
void CoherentPionReco::reconfigure(fhicl::ParameterSet const & p)
{

fGenieGenModuleLabel 	= p.get< std::string >("GenieGenModuleLabel");
fTrackModuleLabel       = p.get< std::string >("TrackModuleLabel");
fVertexModuleLabel      = p.get< std::string >("VertexModuleLabel");

}

// #############################################################
// ###                       Begin Job                       ###
// #############################################################
void CoherentPionReco::beginJob()
{

// ######################################
// ### Declare the TFileService (tfs) ###
// ######################################
art::ServiceHandle<art::TFileService> tfs;

}


// ############################################################
// ###                      EVENT LOOP                      ###
// ############################################################
void CoherentPionReco::analyze(art::Event const & evt)
{

// ############################
// ### MC truth information ###
// ############################
art::Handle< std::vector<simb::MCTruth> > mctruthListHandle;
std::vector<art::Ptr<simb::MCTruth> > mclist;
if (evt.getByLabel(fGenieGenModuleLabel,mctruthListHandle))
   {art::fill_ptr_vector(mclist, mctruthListHandle);}

// ###########################
// ### BackTracker service ###
// ###########################
//art::ServiceHandle<cheat::BackTracker> bt;
//const sim::ParticleList& plist = bt->ParticleList();

// #####################################
// ### Getting the Track Information ###
// #####################################
art::Handle< std::vector<recob::Track> > trackListHandle; //<---Define trackListHandle as a vector of recob::Track objects
std::vector<art::Ptr<recob::Track> > tracklist; //<---Define tracklist as a pointer to recob::tracks

// ##################################################
// ### Getting the 3d Vertex (vertex3dListHandle) ###
// ##################################################
art::Handle< std::vector<recob::Vertex> > vertex3dListHandle;
evt.getByLabel(fVertexModuleLabel,vertex3dListHandle); 


// === Filling the tracklist from the tracklistHandle ===
if (evt.getByLabel(fTrackModuleLabel,trackListHandle))
   {art::fill_ptr_vector(tracklist, trackListHandle);}


// ######################################################
// ### Declare a boolian that will get changed if the ###
// ###       interaction is CC-Coherent Pion          ###
// ######################################################
bool EventIsCoherentPion = false;

// ### Loop over all the GENIE particles ###
for (unsigned int aa = 0; aa < mclist.size(); aa++)
   {
   // ### CC-Coherent Pion is defined for Interaction Type = 1097 ###
   if(mclist[aa]->GetNeutrino().InteractionType() == 1097)
      {
      EventIsCoherentPion = true;
   

      }//<---End check the interaction type
   
   }//<---end aa loop

// ####################################################
// ### Skip the event if it is not CC-Coherent Pion ###
// ####################################################
if(!EventIsCoherentPion){return;}


// #####################################################################
// ### Skip the event if there are fewer than 2 tracks reconstructed ###
// #####################################################################
if(tracklist.size() <= 1){return;}


// #####################################################################
// ### Skip the event if there are fewer than 1 vertex reconstructed ###
// #####################################################################
if(vertex3dListHandle->size() < 1){return;}


// === Association between SpacePoints and Tracks ===
art::FindManyP<recob::SpacePoint> fmsp(trackListHandle, evt, fTrackModuleLabel);


// ######################################
// ### Loop over reconstructed tracks ###
// ######################################
for(size_t itrk = 0; itrk < tracklist.size(); ++itrk)
   {
   // returns type std::pair<recob::Track::Point_t, recob::Track::Point_t>
   auto trackStartEnd = tracklist[itrk]->Extent();
   
   // returns type std::pair<recob::Track::Vector_t, recob::Track::Vector_t>
   auto larStartEnd = tracklist[itrk]->Direction();
   
   // =============== Example of accessing track information =======================
   std::cout<<"trackStartEnd.first.X() = "<<trackStartEnd.first.X()<<std::endl;
   std::cout<<"trackDirectional Cosine = "<<larStartEnd.first.X()<<std::endl;
   
   
   // ### Grabbing the SpacePoints associated with this track ###
   //ntrkhits[itrk] = fmsp.at(itrk).size();
   std::vector<art::Ptr<recob::SpacePoint> > spts = fmsp.at(itrk);
   
   // ########################################
   // ### Looping over all the SpacePoints ###
   // ########################################
   for (size_t jspts = 0; jspts < spts.size(); ++jspts)
      {
      
      // ===================== EXAMPLE OF ACCESSING SPACEPOINT INFORMATION =============================
      std::cout<<"This spacepoint x position is "<<spts[jspts]->XYZ()[0]<<std::endl;
      
      
      }//<---end jspts

   
   }// end itrk loop



}//<----End Event loop





void CoherentPionReco::endJob()
{
  // Implementation of optional member function here.
}






DEFINE_ART_MODULE(CoherentPionReco)
